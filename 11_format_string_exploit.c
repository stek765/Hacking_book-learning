/*
Arguments:
1) format parameters 
2) format string vulnerability
3) reading from arbitrary memory addresses
4) writing to arbitrary memory addresses
5) direct parameter access 
6) using short writes
7) detours with .dtors


1) Format Parameters – (How printf really works under the hood):
    // Functions like printf() use format specifiers like %d, %s, %x to tell the function what 
    // type of data to print and in what format. These specifiers tell printf to pull values 
    // from the stack, and interpret them in specific ways

    printf("Value: %d\n", 42); // Here, %d tells printf to take an int (4 bytes) from the stack and print it as a decimal number.

    // BUT — and here’s the key for exploitation — if the format string itself comes from user input, like:
    char buffer[100];
    gets(buffer);         
    printf(buffer);      

    // …then the user can inject format specifiers like %x, %s, %n, and printf will obey them blindly.  
    // example Input: %x %x %x

    // !! This makes printf print raw values from the stack, word by word (4 bytes at a time), 
    // revealing potentially sensitive data like pointers, return addresses, etc.

    🔑 THE FUNDAMENTAL IDEA:
    printf doesn’t check if the number of format specifiers matches the number of arguments.
    If the user controls the format string, they can read or manipulate stack data arbitrarily.

    This is the foundation for the vulnerabilities described in the next sections.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

2) Format String Vulnerability – (From harmless bug to powerful exploit):

    🔑 THE CORE IDEA:
    A format string vulnerability happens when user-controlled input is passed directly as the format 
    string to functions like printf, fprintf, sprintf, etc.

    printf("%s", user_input);  // ✅ SAFE
    printf(user_input);        // ❌ VULNERABLE

    // Now the user can insert special format specifiers (%x, %s, %n, etc.) and printf will try 
    // to interpret them as if there were arguments on the stack — but there aren’t. 
    // So it just pulls random values from the stack and prints them, which can leak memory contents or worse.

    //  Why is this dangerous?
        •	%x → reads and prints data from the stack (e.g. secrets, return addresses, function pointers).
        •	%s → treats stack data as pointers and prints the contents, which may point to any memory.
        •	%n → writes the number of characters printed so far into a memory location (user-controlled!), meaning you can write arbitrary values to arbitrary addresses.
    // This last one (%n) is what turns this into a powerful exploit — not just reading, but writing memory.
    
    // Example:
    char input[256];
    gets(input);              
    printf(input); 
    
    // with an input like: AAAA %x %x %x %x, 
    // printf will print the next four 4-byte values from the stack, which could include sensitive data
    // -> AAAA deadbeef 41414141 bffffccc ... (You just leaked 3 stack values)

    // Another input: AAAA %n -> Now printf will try to write the number of characters printed so far (e.g. 4) into the address found on the stack, which the user can manipulate with padding or address spraying.
    // The format specifier %n is not for printing anything.
    // Instead, it tells printf() to write the number of characters printed so far into an integer pointer taken from the stack.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

3) Reading from Arbitrary Memory Addresses – (How to leak sensitive data):

    🔑 THE CORE IDEA:
    By using format specifiers like %x, %s, and direct parameter access (%N$x), an attacker can 
    read memory values from anywhere, not just the stack.

    // Example:
    char input[256];
    gets(input);          // user-controlled input
    printf(input);        // vulnerable format string

    // Input: %x %x %x %x  (Each %x prints a 4-byte word from the stack)
    // Output: deadbeef 41414141 bffffccc ... (You just leaked 3 stack values)

    // %s is even more powerful:
    // %s tells printf to:
            1.	Read a pointer from the stack
            2.	Follow it
            3.	Print the string it points to
    // So, if the stack contains a pointer to a secret string like: "SECRET_PASSWORD"
    // Then '%s' will print the entire string, because printf will dereference the pointer and print its contents until it hits a null byte (\0).

    // By combining %x, %s, and offset guessing, you can “walk” the stack and find: 
        •	Return addresses
        •	Stack frame pointers
        •	Pointers to heap/stack/globals
        •	Environment variables (e.g., /bin/sh path)
    // You can also use direct parameter access (we’ll cover it in the next section) to target a specific offset
    // Example: %10$s will read the 10th string from the stack, which could be a pointer to a sensitive string.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

4) Writing to Arbitrary Memory Addresses – (How to hijack control flow):

    🔑 THE CORE IDEA:
    The %n format specifier allows writing the number of characters printed so far, into a memory address specified on the stack.
    This can be used to overwrite function pointers, return addresses, or any other critical data.

    // Example:
    char input[256];
    gets(input);          // user-controlled input
    printf(input);        // vulnerable format string

    // Input: AAAA %n
    // Here, printf will write the number of characters printed so far (4 in this case) into the address found on the stack.
    
    // If you can control what’s on the stack, you can make it point to a function pointer or return address.
    // For example, if you know that the 5th value on the stack is a function pointer, you can use:
    // Input: AAAA %5$n 
    // This will write 4 (the length of "AAAA" -> *(int*)0x0804a010 = 4;) into the address of the 5th value on the stack.

    // If that 5th value is a function pointer, you just hijacked control flow!
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

5) Direct Parameter Access – (How to target specific stack values):

    🔑 THE CORE IDEA:
    Instead of just reading/writing sequentially, you can access specific parameters on the stack using %N$x or %N$n.
    This allows precise control over which memory locations you read from or write to.

    // Example:
    char input[256];
    gets(input);          // user-controlled input
    printf(input);        // vulnerable format string

    // Input: %1$x %2$x %3$x
    // This will read the first, second, and third values from the stack directly.
    
    // You can also write to specific parameters:
    // Input: AAAA %1$n
    // This will write the number of characters printed so far (4) into the address of the first parameter on the stack.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// 6) Using Short Writes – (How to bypass length checks):

    🔑 THE CORE IDEA:
    By default, %n writes 4 bytes (32 bits) at once — that’s risky if you’re trying to overwrite a specific part of memory, like just 1 or 2 bytes in a function pointer or GOT entry.
    Short writes allow you to write just 2 bytes (%hn) or 1 byte (%hhn) instead of a full 4.  
    
    -	%n writes 4 byte (es. 0x12345678) — troppo big and risky
	-	%hn writes 2 byte (es. only 0x5678), %hhn writes 1 byte (es. only 0x78)
	-	This way you can write an address in parts, avoiding length checks that might prevent a full 4-byte write.
	    •	before 0x5678 at addr
	    •	after  0x1234 a  addr + 2
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

7) Detours with .dtors – (Run your code when the program exits):

    🔑 THE CORE IDEA:
    -	In C, there’s a section in memory called .dtors (destructors)
	-	It’s a list of function pointers that get called when the program exits
	-	If you overwrite one of those pointers, your code will run when main() finishes
    
    Why is this useful?

    If:
	-	You have a format string vulnerability
	-	But you can’t hijack the flow immediately (e.g., no return address nearby)
	-	You can just wait — overwrite a .dtors entry with your shellcode or system("/bin/sh"), and let the program exit naturally
    
    How to use it:
	1.	Find the address of a .dtors entry (e.g., 0x08049f24)
	2.	Use %n, %hn, or %hhn to write your desired address there
	3.	Wait for the program to exit
	4.	Boom — it runs your payload
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

